# 섹션 1-5 정리

인터넷에서 컴퓨터 둘은 어떻게 통신할까?

간단히 생각하면 한 컴퓨터에서 다른 컴퓨터에 통신하고자 하는 내용을 보내는 것일 것

→ IP 프로토콜을 통해 클라이언트는 서버의 주소(IP)에 패킷이라는 통신 단위로 데이터를 전달한다.

→ IP 프로토콜의 역할은 지정한 IP주소에 데이터를 전달하는 것이다.

하지만 컴퓨터와 컴퓨터의 통신이라고 생각할 수 있지만 통신을 위해서는 수많은 노드들을 거쳐 간다.

→ IP프로토콜 만으로는

1.  `비연결성` (패킷을 받을 대상이 없거나 서비스가 불능상태여도 패킷을 전송함)

2.  `비신뢰성`(중간에 패킷이 사라지거나, 패킷의 순서가 바뀌는 경우)

3.  같은서버에서 통신하는 애플리케이션이 여러개라면 무엇과 통신하는지 프로그램을 구분하기 힘들다.

**인터넷 프로토콜의 4계층**

애플리케이션 계층 → HTTP, FTP

전송 계층 → TCP, UDP

인터넷 계층 → IP

네트워크 인터페이스 계층 (라우터, 스위치 같은 장치들?)

**흐름**

1. 프로그램이 메시지 생성함.
2. socket 라이브러리를 통해 메시지를 os로 전달.
3. os는 메시지를 TCP 정보를 생성해서 포장함.
4. IP는 패킷을 생성하고 TCP 데이터를 포함하여 포장함.
5. 해당 패킷은 LAN 드라이버, LAN 장비등으로 인터넷을 통해 서버로 전송된다.
6. 서버는 받은 패킷을 분해하면서 메시지를 전달 받는다.

IP 프로토콜에는 출발지 IP, 목적지 IP, 기타 내용들이 들어있으며

TCP 프로토콜에는 출발지 PORT, 목저지 PORT, 전송 제어, 순서 ,검증 정보 등 기타 정보들이 포함되어 있다.

**TCP의 특징**

TCP의 특징은 연결지향이라는 것이다. TCP 3 way handshake(SYN → ACK, SYN → ACK)을 통해서 서버와 클라이언트의 논리적인 연결을 설정함으로서 IP프로토콜이 보장해주지 않던 연결성과 신뢰성을 보장해준다.

정리하자면 `연결지향,` `데이터 전달 보증,` `순서 보장` . 현재 대부분 TCP를 사용하고 있으며 HTTP의 근간이 되는 1.1버전에서는 TCP를 주로 사용한다. 하지만 최근에 3버전 같은 경우에는 TCP가 연결지향적이기 때문에 생기는 성능상의 단점을 극복할 수 있는 UDP를 사용하는 경우가 늘어가고 있다고 하는데, 그냥 현업에서는 TCP를 주로 사용한다고 한다.

**UDP의 특징**

UDP의 특징은 TCP보다 IP 프로토콜에 비슷하다고 생각하면 된다. 연결지향적인 TCP와 달리 **서버와 클라이언트를 논리적으로 연결해주지 않으며, 데이터의 전달을 보증해주지 않으며, 순서 역시 보장되지 않는다.** 하지만 이러한 것들을 지원하지 않는 만큼 **단순하기 때문에 빠르다**.

정리하자면 IP와 거의 비슷하지만 추가적으로 PORT번호와 오류를 체크하는 체크섬 정도만 추가한 것이라고 보면 된다. 기능이 없는 만큼 내 입맛대로 이것저것 설정하고 싶으면 UDP를 사용하면 된다.

**PORT**

포트는 간단하게 말하자면 IP주소가 아파트의 이름이라면 포트번호는 동, 호수라고 생각하면 된다. **같은 IP내에서 프로세스를 구분할 때 사용**한다. 0 ~ 65535까지 할당이 가능하며 **0~1023은 주로 잘 알려진 포트**로서 사용하지 않는 것이 좋다. 대표적인 포트 번호라면 **FTP-20, 21** TELNET-23, **HTTP-80,** **HTTPS-443**이 있다.

**DNS**

**DNS는 간단하게 생각하며 주소록이라고 생각하면 된다.** DNS가 존재하기 때문에 기억하게 어려운 **IP주소를 우리가 이해하기 쉬운 도메인 주소로 접근**할 수 있는 것이며 **서버의 IP주소가 변경되어도 같은 도메인에 접속하면 되는 것**.

**URI, URL**

`URI`는 리소스를 고유하게 식별하는 식별자로서 URL과 URN을 포함하는 개념이다. `URL`은 리소스가 있는 위치를 지정한다.

**URL의 문법**은

프로토콜 + 호스트명 + 포트번호 + 패스(/search) + 쿼리 파라미터로 구성되어있다. 만약 프로토콜이 잘 알려진http나 https 같은 것들이라면 포트번호를 생략할 수 있다.

**HTTP**

HTTP의 목적은 처음에는 주로 HTML을 전송하는 것이었으나 **최근**에는 **HTML뿐만 아니라 이미지, 음성, 영상, 파일 , JSON, XML등 거의 모든 형태의 데이터를 전송하는데 사용**하며 심지어 서버간에 데이터를 주고 받을 때에도 대부분 HTTP를 사용한다. 그만큼 중요하다는 것!

HTTP는 주로 1.1버전에서 대부분의 것들이 제정되었고 HTTP/2나 HTTP/3은 주로 성능 개선에 관련된 것들이므로 1.1에 대해서 잘 알아놓는 것 이 중요하다.

**HTTP의 특징**

1. 클라이언트 서버 구조 → 클라이언트와 서버로 구조화를 함으로써 클라이언트는 인터페이스 같은 것들에 집중하고 서버에는 비즈니스로직과 같은 것들에 집중할 수 있게 되었다.
2. 무상태(Stateless) 프로토콜, 비연결성 → 클라이언트의 정보를 기록하고 있지 않기 때문에 다양한 상황에서 더욱 유연하게 대처 할 수 있음.
3. HTTP 메시지
4. 단순하며 확장 가능하다.

클라이언트 서버 구조

클라이언트는 서버에 요청(Request)를 보내고 응답을 기다린다. 서버는 요청에 대한 결과(Response)를 만들어서 응답한다.

무 상태 프로토콜

서버가 클라이언트의 상태를 보존하지 않는다. 따라서 서버의 확장성을 높일 수 있다. 하지만 클라이언트가 더욱 상세한 내용의 데이터를 전송해야 함.

예시) Stateful

- 고객: 이 노트북 얼마인가요?
  • 점원: 100만원 입니다.
  • 고객: 2개 구매하겠습니다.
  • 점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?
  • 고객: 신용카드로 구매하겠습니다.
  • 점원: 200만원 결제 완료되었습니다.

점원이 바뀐다면?

- 고객: 이 노트북 얼마인가요?
  • 점원A: 100만원 입니다.
  • 고객: 2개 구매하겠습니다.
  • 점원B: ? 무엇을 2개 구매하시겠어요?
  • 고객: 신용카드로 구매하겠습니다.
  • 점원C: ? 무슨 제품을 몇 개 신용카드로 구매하시겠어요?

예시) Stateless

고객: 이 노트북 얼마인가요?
• 점원: 100만원 입니다.
• 고객: 노트북 2개 구매하겠습니다.
• 점원: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?
• 고객: 노트북 2개를 신용카드로 구매하겠습니다.
• 점원: 200만원 결제 완료되었습니다.

stateful하다면 클라이언트에게는 항상 같은 서버가 유지되어야 하며 중간에 서버가 장애나면 문제가 생김. 하지만 stateless하다면 다른 서버여도 상관이 없음

**한계**

하지만 모든 것을 무상태로 설계할 수는 없음 → 로그인과 같은 상황에서는 상황을 유지해야 하므로 쿠키나 세션등을 이용해서 상태를 유지한다. 이러한 상태 유지는 최소화하자.

**HTTP API 설계**

HTTP의 설계의 원칙

1. 리소스를 URI에 매핑할 수 있도록 하자
2. 하지만 항상 이렇게 설계할 수 없기 때문에 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스는 컨트롤 URI를 사용하자. 하지만 최대한 줄이고 동사를 사용하자

**GET** → 주로 **리소스 조회**에 사용한다. 쿼리 스트링을 이용하거나 Response Body를 사용할 수 있지만 후자는 지원하지 않는 서버들이 많으므로 전자를 이용하자.

**POST** → POST는 만능이다. 주로 등록에 사용하는 것은 사용하지만 클라이언트가 제공한 요청 데이터를 서버가 처리해야 하는 모든 경우에 POST를 사용할 수 있다. 서버가 리소스의 URI를 생성하고 관리하며 **컬렉션**이라고 한다.

**PUT** → PUT은 기존의 URI에 만약 데이터가 존재한다면 데이터를 덮어 씌우고 없다면 생성하는 메소드이다. 이 경우 클라이언트가 리소스의 URI를 알아야하고 관리한다. **스토어**라고 하기도 한다.

PATCH -> 리소스의 특정 값만 변경하고 싶을 때

DELETE → 삭제
