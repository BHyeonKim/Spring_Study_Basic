# Section 7. HTTP 헤더 1 - 일반 헤더

## HTTP 헤더 개요

HTTP 전송에 필요한 모든 부가정보가 있음.

옛날에는 헤더를 분류를 했음.

회원이라는 리소스를 HTTP로 표현을 한거잖아.

회원이라는 리소스를 실제 HTTP로 전달될때는 JSON이 될수있고 HTML이 될수도 있음. 그래서 표현을 뭐로 했는지를 정확히 말해주어야함.

그것이 엔티티 즉 표현임.

## 표현

Length는 표현 데이터의 길이

표현데이터 인코딩

표현데이터를 압축했으면 인코딩 헤더를 추가.

표현 데이터의 자연언어

ko 는 한국어 en은 영어

transfer encoding 을 사용하면 length를 사용하면 안돼 왜냐면 그 안에 어차피 들어가 있기 때문임.

## 콘텐츠 협상

협상(콘텐츠 네고시에이션)

클라이언트가 선호하는 표현 요청

서버가 노력을 해달라고 클라이언트가 요청을하는것임. 

accept language 적용 전

한국어 브라우저를 사용해도 서버는 클라이언트가 어떤 언어를 선호하는지 모르니까 기본 영어를 보내줘

적용 후

accept language 적용 후

ko를 선호한다고 보내 그러면 서버가 한국어를 지원한다면 보내줌.

헤더로 이런것들을 처리하는것임.

복잡한 예시

한국어로 요청을 했어. 근데 기본이 독일어야. 근데 독일어는 너무어렵잖아. 한국어가 안되면 그래도 영어가 나은데.. 그래서 우선순위가 필요해.

Quality Values가있어. ko q 는 0.9고 us q 는 0.8이야 이런식으로 1에 가까울수록 높은 우선순위인거임. 저기있는 언어 순서대로 이제 보내주는거지.

구체적인것이 우선임.

text/* 과 text/plain 있으면 머가 더 구체적이야? plain이 구체적이지 그런거임.

## 전송방식

단순 전송 ⇒ 한번에 요청하고 한번에 쭉 받는거

압축 전송 ⇒ 서버에서 gzip으로 압축한걸 받는거임. 서버는 content encoding이라는걸 추가해서 보내줘야 클라이언트가 받아서 풀수있음.

분할 전송 ⇒ chunked ⇒ 덩어리를 쪼개서 보내는것.

서버에서 5바이트 hello가 만들어지면 보내고 또 만들어지면 보내고 해 마지막저 줄바꿈이 오면 끝난거임. 용량이 큰걸 보낼때 서서히 보내는것임. 이거는 content length를 보내면 안됨.

범위 전송 ⇒ 받다가 중간에 끊겼어. 그걸 다시 받으면 아까우니까 범위를 지정해서 클라이언트가 요청하면 그부분만 서버가 보내주는것임.

## 일반 정보

from 유저 에이전트의 이메일 정보

referer 진짜 많이 사용함. 이전 웹 페이지 주소. 요청할때 헤더에 referer 이전 요청 웹페이지 주소가 있음. 뒤로가기 하면 저기로 가는거임.

user agent 내 웹브라우져, 클라이언트의 애플리케이션 정보임.

server 요청을 처리하는 origin 서버의 소프트웨어 정보

## 특별한 정보

host 요청에서 사용, 필수값임, 서버의 ip가 200.200.200.2 라고 해. 한 서버안에 여러 애플리케이션이 돌아가고 있을 수 있어. 클라이언트가 hello하고 요청을 보내. 그러면 서버는 a로 가야하는지 b로가야하는지 c로 가야하는지 모를때가있어. 그걸 방지하기 위해서 host에 정보를 적어주면 서버가 어디로 가는지 눈치채고 해줌.

location 웹브라우저가 3xx 응답에 결과에 location 헤더가 있으면 location 위치로 자동 이동

allow 허용 가능한 http 메서드 allow에 post가 없지 그러면 post는 지원안해주는거임. 그래야 브라우저가 알수있으니까. 근데 서버에서 많이 사용하지 않음.

retry-after 서비스가 언제까지 불능인지 알려줄 수 있음. 

## 인증

인증 authorization 헤더가 있음. 클라이언트의 인증 정보를 서버에 전달

인증하는 메커니즘마다 밸류에 들어가는것이 다름. oauth 인증 등등

401에 unauthoirzed 응답과 함께 사용함.

## 쿠키

set cookie 는 서버에서 클라이언트로 쿠키 전달

cookie 클라이언트는 서버에서 받은 쿠키 저장

쿠키미사용

로그인해도 서버는 로그인한 사용자인지 아닌지 확인할 방법이없음.

http는 stateless 프로토콜이야. 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.

대안 - 모든 요청에 사용자 정보 포함

근데 모든 요청과 링크에 사용자 정보를 전부 포함해야해. 이건 큰 문제가있음.

모든 요청에 정보를 넘기는 문제

모든 요청에 사용자 정보가 포함되도록 개발 해야함

브라우저를 완전히 종료하고 다시 열면?

쿠키

로그인 ⇒ set Cookie에 넣어서 보내

웹브라우저는 쿠키 저장소에 저장을 해.

모든 요청에 쿠키 정보가 자동 포함됨

쿠키는 사용자 로그인 세션 관리에 정말 많이 사용함.

쿠키 정보는 항상 서버에 전송되므로 최소한의 정보만 사용해야함.

보안에 민감한 데이터는 저장하면 안됨..

쿠키 생명주기

만료일이 되면 쿠키 삭제

만료 날짜를 생략하면 브라우저 종료시 까지만 유지

쿠키 도메인

쿠키 경로

path home 하면 이 경로를 포함한 하위 경로 페이지만 쿠키 접근 가능함.

일반적으로 루트로 지정하긴함
