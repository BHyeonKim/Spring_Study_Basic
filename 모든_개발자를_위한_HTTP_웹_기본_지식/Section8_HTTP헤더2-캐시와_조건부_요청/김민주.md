## 🧸 캐시 기본 동작

### 캐시가 없을 때

> 1. `GET /star.jpg`
> 2. `HTTP/1.1 200 OK Content-Type:image/jpg` + 이미지 1.1M 응답
> 3. 똑같은 요청을 한 번 더 반복하면 서버가 다시 이미지 응답

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터 다운로드
- 인터넷 네트워크는 느리고 비쌈, 느린 브라우저 로딩으로 느린 사용자 경험

### 캐시 적용

> 1. `GET /star.jpg`
> 2. `HTTP/1.1 200 OK ... **cache-controlL:max-age=60` + 이미지
> 3. 응답 결과를 브라우저 캐시에 저장 (60초 유효)
> 4. 똑같은 요청을 한 번 더 요청하기 전에 캐시에서 데이터를 찾음
> 5. 세 번째 요청을 할 때 캐시 유효 시간 검증으로 유효시간이 만료된 것을 알았다면 서버에 다시 요청
> 6. 응답으로 받은 데이터를 다시 캐시에 저장

- 캐시 가능 시간동안 네트워크 사용하지 않음
- 비싼 네트워크 사용량을 줄임, 빠른 브라우저 로딩으로 빠른 사용자 경험
- 캐시 유효 시간이 초과하면, 서버를 통해서 데이터를 다시 조회하고, 캐시 갱신
  - 다시 네트워크 다운로드 발생
  - 로컬과 서버의 데이터가 달라질 수 있기 때문에 갱신 추천
- 유효시간이 지났을 때에도 서버와 데이터가 달라지지 않았다면 굳이 갱신할 필요가 있을까?

## 🧸 검증 헤더와 조건부 요청1

- 캐시 유효 시간이 초과해서 서버에 다시 요청했을 때
  - 서버에서 기존 데이터를 변경 : 다시 요청해서 데이터 갱신(다운로드)
  - 서버에서 기존 데이터를 변경하지 않음 : 갱신할 필요가 있을까?
- 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용하기 위해서 클라이언트의 데이터와 서버의 데이터가 같다는 것을 검증

### 검증 헤더 추가

- `Last-Modified: [데이터 최종 수정일]`를 응답 헤더에 포함
- 캐시에 데이터 최종 수정일도 저장해둠
- 서버에 요청을 보낼때 `if-modified-since:[데이터 최종 수정일]`을 요청 헤더에 포함
- 데이터가 수정되지 않았다면 HTTP 응답을 만들 때 **`304 Not Modified`**를 내보냄
  - **HTTP 바디를 전송하지 않음**
  - 네트워크 부담 감소
- 클라이언트는 304를 받으면 캐시를 다시 세팅

## 🧸 검증 헤더와 조건부 요청2

- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - `Last-Modified`, `ETag`
- 조건부 요청 헤더
  - 검증 헤더로 조건에 따른 분기
  - `If-Modified-Since: Last-Modified` 사용
  - `If-None-Match: Etag` 사용
  - 조건이 만족하면 `200 OK`, 만족하지 않으면 `304 Not Modified`

### `If-Modified-Since:` 이후에 데이터가 수정되었을 때

- **데이터 미변경**
  - **`304 Not Modified`** 헤더 데이터만 전송(BODY 미포함)
  - 전송 용량 0.1M(헤더 0.1M, 바디 1.0M)
- **데이터 변경**
  - **`200 OK`** 모든 데이터 전송(BODY 포함)
  - 전송 데이터 용량 1.1M(헤더 0.1M, 바디 1.0M)
- 1초 미만 단위로 캐시 조정 불가능
- 날짜 기반의 로직 사용
  - 데이터를 수정해서 날짜는 다르지만 데이터 결과가 같은 경우
  - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
    - 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

### `ETag, If-None-Match`

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
  - `ETag: "v1.0", Etag: "a2jiodwjekjl3"`
- 데이터가 변경되면 이름을 바꾸어서 변경(Hash를 다시 생성)
  - `ETag: "aaaa"` -> `Etag: "bbbb"`
- 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기
- `If-None-Match:[ETag 값]` 요청 보내서 검증
- **캐시 제어 로직을 서버에서 완전히 관리**

## 🧸 캐시와 조건부 요청 헤더

### 캐시 제어 헤더

- `Cache-Control`, `Pragma`, `Expires`

### `Cache-Control`

- 캐시 지시어(directives)
- `Cache-Control: max-age`
  - 캐시 유효 시간, 초 단위
- `Cache-Control: no-cache`
  - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
- `Cache-Control: no-store`
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨
  - 메모리에서 사용하고 최대한 빨리 삭제

### `Pragma`

- `Pragma: no-cache`
  - No cache처럼 동작
- HTTP 1.0 하위 호환

### `Expires`

- `expires: Mon, 01 Jan 1990 00:00:00 GMT`
- 캐시 만료일을 정확한 날짜로 지정
- 지금은 더 유연한 `Cache-Control:max-age` 권장
  - 구체적인 날짜보다 초 단위 지정이 훨씬 더 유연!
  - `max-age`와 함께 사용하면 `expires`는 무시됨

### 검증 헤더와 조건부 요청 헤더

- 검증헤더(Validator)
  - `ETag: "v1.0", ETag: "aaaaaa"`
  - `Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT`
- 조건부 요청 헤더
  - `If-Match`, `If-None-Match` : `ETag` 값 사용
  - `If-Modified-Since`, `If-Unmodified-Since` : `Last-Modified` 값 사용

## 🧸 프록시 캐시

### 원 서버 직접 접근 상황

- 한국에 있는 클라이언트가 미국에 있는 원서버를 접근할 때 접근 시간 : 500초
- 느리다!

### 프록시 캐시 도입

- 한국에 프록시 캐시 서버(public 캐시)가 있다면?(CDN 서비스)
  - 클라이언트(private 캐시)가 프록시 서버 접근 시간 : 100ms
  - 미국에 있는 원 서버 접근 : 400ms
- 응답 속도가 더 빨라짐

### `Cache-Control` : 캐시 지시어(directives)

- `Cache-Control: public` : 응답이 public 캐시에 저장되어 됨
- `Cache-Control: private` : 응답이 해당 사용자만을 위한 것임(기본값)
- `Cache-Control: s-maxage` : 프록시 캐시에만 적용되는 max-age
- `Age: 60`(HTTP 헤더) : 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초 단위)

## 🧸 캐시 무효화

- 확실한 캐시 무효화 응답
  - 브라우저가 임의로 캐시로 저장해버릴 수 있음
- `Cache-Control: no-cache, no-store, must-revalidate`
  - `no-cache` : 데이터는 캐시해도 되지만 항상 **원 서버에 검증**
  - `no-store` : 데이터에 민감한 정보가 있으므로 저장하면 안됨
  - `must-revalidate` : 캐시 만료후 최초 조회시 **원 서버에 검증**, 원서버 접근 실패시 오류 발생
- `Pragma: no-cache`

### `no-cache` vs `must-revalidate`

#### `no-cache`

> 1. 캐시 서버 요청 `no-cache + ETag`
> 2. 원 서버 요청
> 3. 원 서버 검증
> 4. 정상 응답

#### 만약 네트워크가 단절되어서 원 서버에 접근이 불가하다면?

> 1. 캐시 서버 요청
> 2. 원 서버에 접근할 수 없는 경우 캐시 서버 설정에 따라서 캐시 데이터 반환(오류 보단 예전 데이터)
> 3. 정상 응답 `200 OK`

#### `must-revalidate`

> 1. 캐시 서버 요청
> 2. 원 서버에 접근 할 수 없는 경우 항상 오류 발생 `504 Gateway Timeout`
> 3. 웹 브라우저 응답
