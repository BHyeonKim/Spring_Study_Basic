# [HTTP 메서드]

# #1. HTTP API를 만들어보자

## “API URI 고민”

> URI (Uniform Resource Identifier)
>
- 리소스의 의미는 뭘까?
    - 회원을 등록하고 수정하고 조회하는게 리소스가 아니다! (동작일 뿐)
    - **회원이라는 개념 자체가 리소스**
- 리소스를 어떻게 식별하는게 좋을까?
    - 회원을 등록하고 수정하고 조회하는 것을 모두 배제
    - 회원이라는 리소스만 식별하면 된다 → **회원 리소스를 URI에 매핑**
- **“리소스 식별, URI 계층 구조 활용”**
    - **회원** 목록 조회 : /members
    - **회원** 조회, 등록, 수정, 삭제 : /members/{id}
        - 하지만 이를 어떻게 구분해야할까
    - 참고 : 계층 구조상 상위를 컬렉션으로 보고 **복수 단어 사용 권장**

## “리소스와 행위를 분리”

> 가장 중요한 것은 리소스를 식별하는 것
>
- **URI는 리소스만 식별!**
- 리소스와 해당 리소스를 대상으로 하는 **행위**를 분리
- 리소스 : 회원
- 행위 : 조회, 등록, 삭제, 변경
- 리소스믄 명사, 행위는 동사
- 그렇다면 행위는 어떻게 구분을 할까
    - **HTTP 메서드**

---

# #2. HTTP 메서드 - GET, POST

## “HTTP 메서드 종류”

- GET : 리소스 조회
- POST : 요청 데이터 처리
- PUT : 리소스를 대체, 해당 리소스가 없으면 생성
    - 회원 저장을 하려고 할 때, 있으면 대체하고 없으면 신규 등록
- PATCH : 리소스 부분 변경
    - 회원의 이름 또는 나이 등 일부분을 수정
- DELETE : 리소스 삭제

### “기타 메서드”

- HEAD : GET과 유사하지만 Body를 제외하고 상태 줄과 Header만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)를 설명 (CORS에서 활용)
    - Preflight 요청을 OPTIONS메서드로 보내더라구요!!!!!!! 직접경험함
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

## “GET”

- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아 권장하지 않음

## “POST”

- 요청 데이터 처리
- **메시지 Body를 통해 서버로 요청 데이터 전달**
- 서버는 요청 데이터를 **처리**
    - Body를 통해 들어온 데이터를 처리하는 모든 기능을 수행
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

### “정리”

- 새 리소스 생성(등록)
    - 서버가 아직 식별하지 않은 새 리소스 생성
- 요청 데이터 처리
    - 단순히 데이터를 생성하거나, 변경하는 것을 넘어 **프로세스를 처리해야 하는 경우**
        - 결제 완료 → 배달 시작 → 배달 완료
    - POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
- 다른 메서드로 처리하기 애매한 경우
    - JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우
    - 애매하면 그냥 POST

---

# #3. HTTP 메서드 - PUT, PATCH, DELETE

## “PUT”

- **리소스를 (완전히)대체**
    - 리소스가 있으면 대체
    - 리소스가 없으면 생성
    - 쉽게 말해 덮어버립
- **(중요!) 클라이언트가 리소스를 식별**

![1.png](images%2F1.png)

  POST

![2.png](images%2F2.png)

  PUT

    - 클라이언트가 리소스의 위치를 알고 URI를 직접 지정 (100번 지정!)
      → POST와의 큰 차이점

### “주의점 : 리소스를 완전히 대체한다”

- `username`이 kim이고 `age`가 20인 `Member`가 있다고 가정
- `username`을 park으로 수정하고자 PUT으로 { “username” : “park” } 전달
- 결과 → `username`은 park으로 수정되었지만, `age`필드가 온데간데없이 삭제
- Why? PUT은 **리소스를 완전히 대체하기 때문**
- 이를 해결하기 위해 등장한 메소드 → PATCH

## “PATCH”

![3.png](images%2F3.png)

- 리소스 부분 변경

## “DELETE”

![4.png](images%2F4.png)

- 리소스 제거

---

# #4. HTTP 메서드의 속성

## “안전 (Safe)”

- **여러번 호출해도 리소스를 변경하지 않는다.**
    - Q: 계속된 호출로 로그가 쌓여 장애가 발생하는 것에 대해선?
    - A: **리소스에 대한 안전만 고려**하기 때문에 고려 대상이 아니다.

## “멱등 (Idempotent)”

- 한 번 호출하든 100번 호출하든 **결과가 항상 똑같다.**
- 멱등 메서드
    - GET : 한 번 조회하든, 100번 조회하든 같은 결과 조회
    - PUT : 결과를 대체하는 메서드이므로, 같은 요청을 여러 번 해도 계속 덮어씌워지고 최종 결과는 같다.
    - DELETE : 결과를 삭제한다. 같은 요청을 여러 번 해도 삭제된 결과는 똑같다.
    - POST : **멱등이 아니다.** 두 번 호출하면 다른 결과가 나올 수 있다.
- 활용
    - 자동 복구 매커니즘
    - 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 판단 근거
- **Q: 재요청 중간에 다른 곳에서 리소스를 변경해버리면?**
    - 사용자 1 : GET → username: A, age: 20
    - 사용자 2 : PUT → username: A, age: 30
    - 사용자 1 : GET → username: A, age: 30
- **A: 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.**

## “캐시 가능 (Cacheable)”

- **응답 결과 리소스를 캐시에서 사용해도 되는가?**
- GET, HEAD, POST, PATCH 캐시 가능
    - **실제로는 GET, HEAD 정도만 캐시로 사용**
    - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음