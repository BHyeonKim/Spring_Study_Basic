# Section 3. HTTP 기본

## 0. 모든 것이 http

http 메시지에 모든것을 넣어서 전송해 서버간에 통신할때 tcp 통해서 연결해서 데이터 연결하는 경우보다는 http 연결을 통해 데이터는 전달하는 경우가 많음.

http 1.1 을 엄청 많이 사용하고 있기 때문에 우리에게 제일 중요해 2 랑 3은 성능 개량에 초점이 맞추어져있음. http 1.1 도 97년 99년 14년에 개정이 됨. 

기반 프로토콜은 http 1.1 이나 2는 tcp 프로토콜위에서 동작함. 근데 http 3 는 udp 위에서 개발된다.

tcp 는 위에서 말햇던것처럼 기본적인 데이터나 메커니즘 자체가 속도가 빠른 매커니즘은 아니기 때문에 어플리케이션레벨에서 성능을 최적화 할 수 있도록 개량해놓은게 udp 위에서 개발된 Http 3 임.

크롬 브라우져에서 f12 를 누르고 hello 를 검색하고 오른쪽 클릭하고 프로토콜 체크 해주면 프로토콜이 쭉 나옴. h2 는 http 2 버젼인것임. 네이버나 구글은 1.1 2 3 을 섞어 사용하고 있음.

http 특징

함 읽어보면될듯. 뒤에서 다 설명한대.

## 1. 클라이언트 서버 구조

클라이언트는 서버에 요청을 보내고 응답을 무지성 대기함.

서버가 응답을 줘야 동작함. 이렇게 분리를 하는게 되게 중요함.

옛날에는 클라이언트와 서버가 분리되어있지 않았음.

분리를 해두면 각각 따로 진화를 할 수 있다. 클라이언트는 몰라도 되는건 몰라도 되고 알아야할것만 알면 됨. 서버도 똑같음. 이런 개념적인 로직이 굉장히 중요함. 

## 2. Stateful, Stateless

stateful ⇒ 상태유지

고객과 점원이 대화하는중 정해진것이 바뀌지 않음.

근데 중간에 점원이 바뀌었어 그러면 다른 점원이 ?? 할거아니야. stateful 은 노트북이라는 상태를 유지하고 그다음대화에는 노트북, 2개 라는 상태를 유지하는거임. 그다음 대화에서 노트북 2개 신용카드 라는 상태를 유지하는 거임. 서버가 클라이언트의 상태를 유지하는게 stateful인것임.

stateless ⇒ 무상태

점원이 고객의 상태를 유지하지않으려면 고객이 말하는 방식을 다르게 해야함, 그러면 어떤 점원에게 구매해도 같은 결과를 얻을 수 있게 됨.

이 두 상태에서는 점원이 중간에 바뀌면 차이가 나게 됨. 무상태 stateless 같은 경우에는 고객이 말하는 방식을 다르게 하기 때문에 중간에 점원이 바뀌어도 상관이 없음.

무상태는 응답서버를 쉽게 바꿀 수 있기 때문에 무한한 서버가 증설 가능해. 고객이 엄청 많아져도 점원을 많이 투입하면 해결할 수 있게 되는거임. 클라이언트 요청이 확 늘어나도 무상태면 그냥 서버만 증설하면 돼. 그래서 무상태가 엄청난 장점이 되는거임.

stateful은 항상 같은 서버가 유지되어야해.

무상태는 클라이언트가 요청을 보낼때 노트북, 2개라는 정보를 포함해서 보내 그러면 서버1이 상태를 보관하지 않기 때문에 중계서버가 그냥 서버2로 요청을 던지면 그냥 서버2가 응답을 주면 되는거임. 중간에 어떤 서버가 죽어도 됨, 그래서 굉장히 좋은거임. 스케일 아웃이 가능해. 수평 확장이 되게 유리해지는거임.

물론 stateless 도 한계가있음. 모든것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있음. 근데 단순한 서비스 소개 화면 이런거는 괜찮아. 근데 로그인같이 상태를 유지하는 거는 서버에 유지를 해줘야해 이런거는 무상태로 못해. 이거는 브라우져에 있는 쿠키로 로그인을 해. 그래서 브라우저 쿠키와 서버 세션등을 이용해서 상태를 유지함. 무턱대고 전부 무상태로 하는건 아님.

그리고 stateless 는 전송하는 데이터가 양이 아무래도 좀 더 많아.

## 3. 비연결성, connectionless

tcp/ip 같은 경우에는 연결을 유지를 함. 요청을 보내고 응답을 받음.

근데 클라이언트 123이 서버와 다 연결이 되어있으면 서버가 끊임없이 리소스를 쓰고 있어야함.

클라이언트 2 3 이 놀고있어도 서버는 계속 연결을 유지시켜주어야함.

연결을 유지하지 않는 모델은 서버 입장에서는 리소스를 최대한 아낄 수 있다는 장점이 있음.

요청할때만 응답을 보내면 됨. 클라이언트가 수만대라고 생각해보면 서버가 최소한의 리소스로 유지할 수 있음.

http 는 기본이 연결을 유지하지 않는 모델임. 한 시간동안 수천명이 동시에 서비스를 사용해도 수천명이 동시에 똑같은 버튼을 누르는게 아니기 때문임. 만약 초단위로 나누면 1초에 몇명밖에 연결이 안되는거임. 그래서 서버 자원을 매우 효율적으로 사용 할 수 있는것이다.

웹브라우저로 사이트를 요청하면 html 뿐만 아니라 자바스크립트, css 등 여러가지 종류의 수많은 자원들이 따라옴. 자원을 받을때마다 연결하고 받고 끊고 이렇게 하면 좀 그래. 그래서 지속연결이라는 걸 사용함. http 2 와 3에서는 훨씬 많이 최적화 되었어.

http 초기에는 연결 종료가 너무 낭비 되었어. http 지속 연결을 하면 좀 낭비가 줄어들어, 요청 응답이 전부 다 끝나면 그다음에 종료함. 

stateless를 기억해야한다.

같은 시간에 딱 맞추어 발생하는 대용량 트래픽 예를들면 선착순 이런거. 그러면 위에서 말했던 비연결성 이런건 소용이 없어. 왜냐면 같은시간에 같은 버튼을 수만명이 누르게 되니까.. 그렇기 때문에 어떻게든 스테이스리스로 머리를 쥐어짜서 설계를 해야해. 첫페이지는 그냥 로그인도 필요없는 정적페이지를 하나 뿌려 그건 그냥 html 이야 사람들이 그걸 보게 하고 그 다음에 버튼을 하나 둬,

그 다음에 놀게한다음에 이벤트 참여 버튼을 누르게 한다던지 하는 방식으로 해결한다.

## 4. http 메시지

http 로 html , text 이미지 음성 영상 파일 등등 모든걸 다 보낼 수 있다.

http 는 요청 메시지와 응답메시지가 구조가 다름.

http 메시지 구조는 시작 라인이있고 헤더가 있고 공백 라인이있고 메시지 바디가 있음. 공백 라인은 무조건 있어야함. 

요청 메시지도 바디 본문을 가질 수 있음.

시작 라인은 리퀘스트 라인 / 스테이터스 라인이 있음. 요청 메시지는 리퀘스트 라인을 사용함.

get post put delete 들이 있음.

서버가 수행해야 할 동작이 지정되어있음.

절대경로에 쿼리 합쳐서 들어가짐. 요청 메시지의 

http 상태코드를 나타내는 사람이 읽을 수 있는 글이 Ok 임.

헤더 필드는 필드 네임과 : 이 들어가고 ows 는 띄어쓰기 해도 되고 안해도 된다는 뜻임.

호스트 띄고 : 은 안됨. 왜? ows 가 없으니까 field name 은 대소문자 구분은 없음. 당연히 밸류는 구분함. http 헤더는 http 전송에 필요한 모든 부가정보가 다 있음. 이게 압축이 되었는지 인증정보 웹브라우저 어떤걸로 요청했는지 등등 캐쉬에대한것도 있고 그럼.

필요시 임의의 헤더 추가도 가능함. 약속된 클라이언트와 서버만 이해를 함.

http 는 단순해. 그리고 크게 성공하는 기술은 단순하지만 확장 가능한 기술이 크게 성공하는 기술임.

지금은 http 의 시대이다.
