# 섹션 1

## 이번 섹션의 목표

우선 스프링이 존재하지 않았던 환경에서 개발을 진행해보면서 불편하고 바꿔야 하는 점들이 무엇인지 직접 느껴보고, 이를 바꿔보는 과정에서 왜 스프링이 나올 수 밖에 없었는지를 알아보자.

**자바의 역사**

EJB → POJO → 스프링과 비슷한 무언가와 JPA의 근간이 되는 HIBERNATE → 스프링, JPA

**스프링의 역사**

EJB → 로드존슨이 더 쉽게 개발하는거 보여줄게 하면서 예제 3만라인을 작성함 → 많은 개발자들이 예제를 보고 수정해가면서 사용함 → 오픈소스 프로젝트로 발전 →스프링의 시작

**스프링이란?**

스프링은 스프링 프레임워크, 스프링 부트, 스프링 데이터, 스프링 시큐리티 등 다양한 기술들의 모음이라고 볼 수 있다.

필수

- 스프링 프레임워크 → 스프링의 핵심 기술
- 스프링 부트 → 여러 스프링 기술들을 편리하게 사용할 수 있도록 해줌

**스프링 프레임워크 키워드**

`핵심 기술` → 스프링 DI 컨테이너, AOP, 이벤트, 기타 등등..

`웹 기술` → 스프링 MVC, 스프링 WebFlux

`데이터 접근 기술` → 트랜잭션, JDBC, ORM 지원, XML 지원

`기술 통합` → 캐시, 이메일 원격 접근, 스케쥴링

`테스트` → 스프링 기반 테스트

**스프링 부트**

스프링을 편리하게 사용할 수 있도록 지원, 이젠 필수가 되었다. 스프링 부트만 사용할 수 있는 것이 아니라 스프링 프레임워크 사용에 도움이 되는 기술임.

- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat같은 웹 서버 내장해서 별도의 웹 서버 설치할 필요 없음
- 손쉬운 빌드 구성을 위한 starter 종속성 제공 (내가 AOP를 사용하고 싶으면 AOP뿐만 아니라 사용하기 위해 필요한 기술들을 모두다 라이브러리에 불러와줌)
- 스프링과 라이브러리 환경 설정
- 메트릭, 상태 확인, 외부 구성과 같은 프로덕션 준비 기능 제공 (모니터링 같은)

### 스프링의 핵심?

스프링의 핵심은 웹 어플리케이션을 만들고 DB 접근을 편리하게 해주고 기타 등등 이러한 결과물이 아니라 자바의 특징인 **객체 지향 언어가 가진 장점과 특징들을 살려내는 프레임워크**이다 → 즉 스프링은 좋은 객체 지향 애플리케이션을 개발 할 수 있게 해주는 프레임워크.

**그러면 좋은 객체 지향 프로그래밍은 뭔데?**

객체 지향의 특징은 우리가 배웠듯이 추상화, 캡슐화, 상속, 다형성을 가지고 있다. 하지만 가장 핵심이 되는 특징은 바로 **Polymorphism(다형성)**이다. 유연하고 변경에 용이하다라는 가장 큰 장점이 다형성을 이용하며 가지기 때문이다.

역할과 구현을 나눴기 때문에 변경이 가능한 대체 가능성이 생긴다.

**좋은 객체 지향 설계**란 즉 인터페이스를 만들어 놓고 **구현체는 유연하게 변경할수 있도록 만드는 것**이다. 이를 위해서 다형성뿐만 아니라 OCP, DIP를 지켜야 함.

클라이언트는 대상의 역할(인터페이스)만 알면 된다.

클라이언트는 구현 대상의 내부 구조를 몰라도 된다.

클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.

클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.

역할 = 인터페이스, 구현 = 인터페이스를 구현한 클래스, 구현 객체

즉 객체 설계시 인터페이스를 먼저 부여하고, 그 역할을 수행하는 구현 객체 만드는 순서 → **인터페이스 설계가 중요하다.**

**다형성의 본질**

인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.

클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

인터페이스 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 필요하다.

그래서 인터페이스를 설계할 때 서비스에 변경이 있더라도 인터페이스 자체가

변경이 없도록 설계하는 것이 매우 중요하고 이게 잘하는 개발자이다.

**스프링과 객체 지향**

스프링은 다형성을 극대화해준다. 스프링에서의 IOC, DI는 다형성을 활용해서 역할(인터페이스)과 구현(인터페이스 구현 객체)을 편리하게 다룰 수 있도록 해준다.

### SOLID (객체 지향 설계 원칙) → 매우 중요

1. **SRP (Single Responsibility Principle) 단일 책임 원칙**

**하나의 클래스에는 하나의 책임만 가져야 한다.** 하나의 책임이라는 것은 모호한 부분이 있는데 클래스마다 그 책임이 작을 수도 클 수도 있기 때문이다. 그래서 단일 책임 원칙을 잘 지켰는지 판단하는 요소는 변경이 있을 때 파급 효과가 작으면 SRP를 잘 지킨 것.

1. **OCP (Open / closed principle) 개방-폐쇄 원칙**

소프트웨어 요소는 **확장에는 열려 있으나 변경에는 닫혀** 있어야 한다.

다형성을 활용한다면 기존의 코드를 변경하지 않고(?) 새로운 코드를 작성해서 확장할 수 있다 → 그래서 다형성이 객체지향에서 가장 중요하고 → 스프링에서도 다형성을 활용할 수 있도록 도와주는 것이다.

다형성을 활용해서 새로운 기능을 추가했지만 결국 클라이언트 코드를 변경할 수 밖에 없음 → **OCP 원칙을 지킬 수 없다** → 이 문제를 해결하기 위해서는 **객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.**

1. **LSP (Liskov substitution principle) 리스코프 치환 원칙**

**다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.**

단순히 컴파일에 성공하는 것을 넘어서는 이야기로 만약 인터페이스에 자동차의 엑셀 기능이 대한 명세가 있다면 엑셀은 자동차의 속도를 증가시키는 기능이기 때문에 만약 자동차의 속도가 줄어들도록 구현을 한다면 리스코프 치환 원칙을 위반하는 것이다.

1. **ISP (Interface segregation principle) 인터페이스 분리 원칙**

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.

**즉 인터페이스를 기능에 맞게 적당한 크기로 잘 쪼개는 것이 중요하다는 뜻.**

1. **DIP (Dependency inversion principle) 의존 관계 역전 원칙**

**프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.**

즉 구현 클래스에 의존하지 않고 인터페이스에 의존하라는 뜻.

입문 편에서 작성한 코드는 사실 DIP를 위반하고 있었음.

MemberRepository m = new MemoryMemberRepository();에서 MemberService는 인터페이스에 의존하지만, 구현 클래스에도 동시에 의존하고 있기 때문에 시스템의 변경이 있으면 코드를 변경해줘야 함. → 멤버 서비스는 멤버 레포지토리 인터페이스에만 의존하도록 설계를 해야 한다.

### 정리

객체 지향의 핵심은 다형성이다.

다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.

다형성 만으로는 SOLID 5 원칙 중 OCP, DIP를 지킬 수 없다.

다형성 말고 추가적인 무언가가 더 필요함 → 그것이 바로 `스프링 컨테이너`이다.

**다시 스프링으로**

스프링은 DI(Dependency Injection) 즉 의존 관계, 의존성 주입과 DI 컨테이너로 다형성 + OCP, DIP를 가능하게 지원해준다. → 클라이언트 코드의 변경 없이 기능 확장

**현실적인 이야기**

당연히 인터페이스부터 전부 설계 해놓고 구체적인 구현에 들어가는 것이 좋을 수 있다, 하지만 인터페이스를 도입하게 되면 **추상화라는 비용**(여러 클래스를 더 선언해야 되고 , 구현 클래스를 살펴보기 위해서는 더 많은 노력이 필요함) 이 들어간다. 그래서 앞으로 **확장 가능성이 없는 기능들은 구체 클래스로 곧바로 구현**해서 사용하는 것도 나쁘지 않다. **확장 가능성이 있다면 인터페이스 설계가 더 좋음.**
