## 🌿 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

### EJB(Enterprise Java Beans)

- 2000년대 초반 자바 진영 표준 기술
- 금융권, 아키텍처에 많이 도입
  - 트랜잭션, 분산 기술에 대한 지원
  - Entiti Bin(ORM) 지원
  - 고가의 비용, 복잡하고 어렵고 느려서 사용하기 어려운 것이 단점

### 하이버네이트(Hibernate)

- EJB에서 제공하는 엔티티빈을 대체하는 ORM기술 제공
  - ORM(Object Relational Mapping) : 어플리케이션과 데이터베이스 연결 시 SQL언어가 아닌 개발언어로 데이터베이스 접근

### JPA

- 표준 인터페이스
- 하이버네이트를 기반으로 정제하여 표준으로 정의
- 구현체로는 하이버네이트, EclipseLink ...
  - 80퍼센트가 하이버네이트

### 스프링의 역사

- 전통적인 J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 뜻으로 지음
- XML → XML 편의 기능 지원 → 자바 코드로 설정 → 자바 8 → 스프링 부트(설정 편의 지원) → 리엑티브 프로그래밍 지원(Node.js처럼 개발)

## 🌿스프링이란?

### 스프링 생태계

- 여러가지 기술들의 모음
  - 스프링 프레임워크, 스프링 부트, 스프링 데이터, 스프링 세션, 스프링 시큐리티 ...
- [프로젝트 소개](https://spring.io/projects)

### 스프링 프레임워크

- 핵심 기술 외 웹, 데이터 접근, 기술 통합, 테스트, 언어 지원
  - 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트 ...
  - 웹 기술 : 스프링 MVC, 스프링 WebFlux
  - 데이터 접근 기술 : 트랜잭션, JDBC, ORM, XML
  - 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
  - 테스트 : 스프링 기반 테스트 지원
  - 언어 : 코틀린, 그루비

### 스프링 부트

- **스프링을 편리**하게 사용할 수 있도록 **지원**하는 프레임워크
  - 꼭 스프링 프레임워크와 함께 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션 쉽게 생성
  - 웹 서버를 내장해서 별도의 웹 서버 설치할 필요 없음
  - 빌드하고 서버 띄우는 과정을 간단하게 사용할 수 있도록 지원
- starter 종속성을 제공하여 빌드 구성이 쉬워짐
- 스프링과 외부 라이브러리(3rd parth)와 조합이 맞는지 확인하고 맞는 버전으로 자동 다운로드
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정을 제공하여 필요한 설정만 커스텀하면 됨

### 스프링

- 스프링 DI 컨테이너 기술 : 스프링 빈 관리
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

### 스프링의 핵심 컨셉

- Java 언어 기반의 프레임워크
  - **객체 지향 언어**
  - **객체 지향 언어가 가진 강력한 특징**을 살려내는 프레임워크

## 🌿 좋은 객체 지향 프로그래밍이란?

- 프로그램을 객체들의 모임으로 파악하고자 하는 것
- 프로그램을 *유연*하고 변경이 *용이*해서 대규모 소프트웨어 개발에 많이 사용
  - 컴포넌트를 쉽고 유연하게 변경하면서 개발
  - 이를 가능하게 해주는 것이 **다형성**

### 다형성

- 역할(인터페이스)에만 의존하고 클라이언트가 실제 구현체를 모르더라도 사용 가능
- 구현체를 다른 구현체로 변경하더라도 클라이언트에게 영향을 주지 않음
  - 클라이언트에게 영향을 주지 않고 새로운 기능 제공 가능
- *역할*과 *구현*을 분리

### 역할과 구현을 분리

- **장점**

  > 클라이언트는 대상의 역할(인터페이스)만 알면 된다.  
  > 클라이언트는 구현 대상의 내부 구조를 몰라도 사용할 수 있다.  
  > 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향이 없다.  
  > 클라이언트는 구현 대상 자체를 변경해도 영향이 없다.

  - 확장 가능한 설계
  - 자바에서는 다형성을 이용해서 역할과 구현을 분리 - 역할 = 인터페이스, 구현 = 인터페이스를 구현한 클래스, 구현 객체 - 객체를 설계할 때 역할과 구현을 명확하게 구분하여 인터페이스를 먼저 설계

- **한계점**
  > 역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경 발생

### 객체의 협력

- 수많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.

### 자바 언어의 다형성

- **오버라이딩**
  - 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능

### 다형성의 본질

- **클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다.**

### 🌿 좋은 객체 지향 설계의 5가지 원칙(SOLID)

### SRP 단일 책임 원칙(Single responsibility principle)

- 한 클래스는 하나의 책임만 가져야 한다.
- *변경*시 파급 효과가 적으면 단일 책임 원칙을 잘 지킨 것

### OCP 개방-폐쇄 원칙(Open/closed principle)

- 가장 중요한 원칙
- 소프트웨어 요소는 **확장에는 열려 있으나 변경에는 닫혀** 있어야 한다.
- 다형성의 활용으로 OCP 개방-폐쇄 원칙을 지킬 수 있음
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
  - 구현체만 변경해주면 새로운 기능을 적용할 수 있음.
  - 다만 구현체 변경 과정에서 클라이언트 코드 변경 발생‼️
    - 스프링 컨테이너로 해결 가능

### LSP 리스코프 치환 원칙(Liskov substitution principle)

- 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 변경할 수 있어야 한다.
- 인터페이스의 규약(정의된 기능)을 구현체에서 변경할 수 없다.

### ISP 인터페이스 분리 원칙(Interface segregation principle)

- 범용 인터페이스 사용을 지양하고 특정 클라이언트를 위한 인터페이스들로 분리
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP 의존관계 역전 원칙(Dependency Inversion Principle)

- 중요한 원칙
- **역할에 의존**
  - 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.
  - 구현 클래스에 의존하지 않고, 인터페이스에 의존하라는 뜻

## 🌿 객체 지향 설계와 스프링

- DI(Dependency Injection) 기술로 다형성과 OCP, DIP가 가능하도록 지원
- 클라이언트 코드의 변경없이 기능 확장
- 모든 설계에 인터페이스를 부여하는 것이 이상적이지만 인터페이스 적용시 추상화 비용 발생
  - 개발자가 동작방식을 알기 위해서는 실제 구현체를 열어봐야 한다.
  - 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고 꼭 필요할 때 리팩터랑
