# 😛 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

---

## 💫 1. 객체 지향 원리 적용 예제

> 악덕 기획자
: 서비스 오픈 직전에 할인 정책을 지금처럼 **고정 금액 할인이 아니라** 좀 더 합리적인 주문 금액당 할인하는 **정률% 할인으로 변경**하고 싶어요. 예를 들어서 기존 정책은 VIP가 10000원을 주문하든 20000원을 주문하든 항상 1000원을 할인했는데, 이번에 새로 나온 정책은 ***10%로 지정***해두면 고객이 10000원 주문시 1000원을 할인해주고, 20000원 주문시에 2000원을 할인해주는 거에요!

순진 개발자
: 제가 처음부터 고정 금액 할인은 아니라고 했잖아요.

악덕 기획자
: 애자일 소프트웨어 개발 선언 몰라요? “**계획을 따르기보다 변화에 대응하기**를”

순진 개발자
: … (하지만 난 유연한 설계가 가능하도록 객체지향 설계 원칙을 준수했지 후후)
> 

<aside>
💡 ***애자일 소프트웨어 개발 선언***

공정과 도구보다 **개인과 상호작용**을
포괄적인 문서보다 **작동하는 소프트웨어**을
계약 협상보다 **고객과의 협력**을
계획을 따르기보다 **변화에 대응하기**를

가치있게 여긴다. 오른쪽에 있는것들에 더 높은 가치를 둔다.

</aside>

- 우리의 순진개발자가 정말 객체지향 설계 원칙을 잘 준수했을까요? 😃
    - 기존의 DiscountPolicy 인터페이스에 Fix가 아니라 RateDiscountPolicy로 갈아끼우자 😃
    
    ![Untitled](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/233d1118-8a8d-430b-9865-cb6b8d05bceb)

    
    - Ctrl + shift + T → Create New Test
    
   ![Untitled 1](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/73eb2853-a0be-4f45-a24b-b1b5cd90fe71)

    

### 💫 1-1. DIP, OCP 위반

- 문제점 발견 - OrderServiceImpl
    
   ![Untitled 2](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/cef1f42d-2c84-464b-83a5-1780fe3ea9f9)

    
    - OCP, DIP같은 객체지향 설계 원칙을 준수한것 처럼 보이지만 사실은 그렇지 않다.
    - ***DIP*** → DiscountPolicy 인터페이스에 의존하면서 DIP를 지킨것 같은데..? = X
        - **추상 (인터페이스)뿐만 아니라** **구체(구현)에도 의존**하고 있다.
        - **추상 (인터페이스)** : DiscountPolicy
        - **구체(구현) 클래스** : FixDiscountPolicy, RateDiscountPolicy → ***DIP 위반***
    - ***OCP***
        - FixDiscountPolicy를 RateDiscountPolicy 로 변경하는 순간 **OrderServiceImpl의 소스 코드도 함께 변경**해야함. → ***OCP 위반***

- 해결책
    - ***DIP 위반*** → 추상에만 의존하도록 변경(인터페이스에만 의존)
    - DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경하면 됨.
        
        ![Untitled 3](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/baf0acbd-4494-4063-96f7-4bacf8b28e9f)

        
        - 오케이! 변경했는데.. 구현체가 없이 어떻게 코드 실행해..? → NPE 에러 발생 ;_;
    - 해결방안
        - 이 문제를 해결하려면 누군가 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현객체를 대신 생성하고 주입해야함!

### 💫 1-2. 관심사의 분리

- 현재까지 **OrderServiceImpl**에서 **DiscountPolicy**의 구현객체를 선택했던건 배우가 배우를 섭외한것과 같은 상황임. 즉, 배우가 공연도하고 섭외까지하는 **다양한 책임**을 진것.
- 관심사의 분리가 필요함.
    - 배우는 본인의 역할인 배역을 수행하는 것에만 집중해야함.
    - 공연을 구성하고, 담당 배우를 섭외하고, 역할에 맞는 배우를 지정하는 ***책임을 담당하는 별도의 “공연기획자”***가 나올 시점!

### 💫 1-3. AppConfig 등장

- APP의 전체 동작 방식을 구성(config)하기 위해, **“구현객체를 생성”**하고 **“연결”**하는 책임을 가지는 별도의 설정 클래스를 만들어야 함.
- AppConfig는 애플리케이션의 실제 동작에 필요한 **“구현객체를 생성”**함.
    
    ![Untitled 4](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/310cd839-0786-4264-ab0c-e99148ea7a92)

    
- AppConfig는 ***생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결) 해줌*.**
    
    ![Untitled 5](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/101ec07e-85e9-4c0d-8500-12cb07d519fd)

    
- 구현체의 입장에서 생성자를 통해 어떤 구현 객체가 들어올지(주입될지)알 수 없다.
- 생성자를 통해서 어떤 구현 객체를 주입할지는 오직 외부(”App Config”)에서 결정된다.
- OrderServiceImpl은 ***의존관계에 대한 고민은 외부에*** 맡기고 ***실행에만 집중***하면 된다.
- Test도 생성자를 주입해서 수정
    
    ![Untitled 6](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/590c1d9b-c27e-43cb-b02f-9d56e215119a)

    

- 결론
    - 객체의 생성과 연결은 AppConfig가 당담.
    - ***DIP 완성*** : 이제 구체 클래스를 몰라도 됨.
    - ***관심사의 분리*** : 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리됨.
    - OrderServiceImpl입장에서 보면 의존관계를 마치 외부에서 주입해주는것과 같다고 해서 ***DI(Dependency Injection)*** 우리말로 ***의존관계 주입*** 또는 ***의존성 주입***이라고 함.

### 💫 1-4. AppConfig 리팩터링

- 현재의 AppConfig를 보면 **“중복”**이 있고, **“역할”**에 따른 **“구현”**이 잘 보이지 않음.
- AppConfig에서 역할들을 드러나게 하는게 중요함.

![Untitled 7](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/1ccbb7db-d94f-4c4a-bd80-fb570c249d2d)


### 💫 1-5. 새로운 구조와 할인 정책 적용

- AppConfig의 등장으로 애플리케이션이 크게 ***사용 영역***과, 객체를 생성하고 ***구성(Configuration)하는 영역***으로 분리 됨.
- FixDiscountPolicy → RateDiscountPolicy 변경
    - **구성 영역만 영향**을 받고, ***사용 영역은 전혀 영향을 받지 않음!*** 이게 끝임!
        
        ![Untitled 8](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/9d911912-9054-434f-a4a6-e221b02efea3)

        

---

## 💫 2. 좋은 객체 지향 설계의 5가지 원칙 적용

- 3가지 적용함.

### 💫 2-1. SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 갖는다
    - 구현객체 생성, 연결책임은 AppConfig가 담당.
    - 클라이언트 객체는 실행하는 책임만 담당

### 💫 2-2. DIP 의존 관계 역전 원칙

- 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”
    - 의존성 주입은 이 원칙을 따르는 방법 중 하나임.
    - 클라이언트 코드가 DiscountPolicy를 추상화 인터페이스에만 의존하도록 코드를 변경함.
    - 이것만으로는 NullPointException 발생!
    - 그리고 AppConfig가 FixDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성해 의존관계를 주입함.

### 💫 2-3. OCP 개방-폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함.
    - 다형성을 사용하고 클라이언트가 DIP를 지킴.
    - 애플리케이션을 사용영역과 구성영역으로 구분함.
    - ***소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있게됨!***

---

## 💫 3. IoC, DI, 컨테이너

### 💫 3-1. IoC 제어의 역전 (Inversion of Control)

- 내가 무언가를 호출하는게 아닌 프레임워크가 내 코드를 대신 호출해 주는 것.
- 제어권이 뒤바뀐다고 해서 제어의 역전이라고 하며, 굉장히 여러곳에서 제어의 역전이 나옴.
- AppConfig가 등장한 후 구현객체는 자신의 로직을 실행하는 역할만 담당함. 프로그램의 제어흐름을 이제 AppConfig가 가져감.
    - 이렇듯 ***프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것***을 ***제어의 역전(IoC)***이라 함.

### 💫 3-2. 프레임워크 vs 라이브러리

- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞음. (JUnit)
    - (JUnit) 나는 테스트코드의 로직만 개발함. 실행과 제어권은 JUnit이랑 테스트 프레임워크가 가져가서 실행함.
    - 또한, 그냥 가져가서 실행하는 것이 아닌 자신만의 라이프 사이클이 있음. BeforeEach를 먼저 실행하고 Test를 실행한다 같은.
    - 나는 필요한 부분만 개발하고 프레임워크에 의해서 적절한 타이밍에 호출이되는것 즉, 제어권을 넘기는것을 제어의 역전이라고 함.
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리.
    - Java객체를 XML로 바꾸거나 JSON으로 바꾸는 라이브러리를 불러 직접 호출하는 상황.

### 💫 3-3. DI 의존관계 주입(Dependenct Injection)

- 의존관계는 “***정적인 클래스 의존관계***와, 실행 시점에 결정되는 ***동적인 객체(인스턴스) 의존 관계***” 둘을 분리해서 생각해야 함.
    - 정적인 클래스 의존 관계
        - 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단 가능.(실행X → 분석O)
        - 이러한 클래스 의존관계 만으로는 실제 어떤객체가 주입될지 알 수 없음.
    - 동적인 객체 의존 관계
        - **“실행 시점(런타임)”**에 실제 생성된 객체를 클라이언트에 전달해서 클라이언트와 서버의 실제 “**의존관계가 연결”**되는 것.
        - 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결함.
        - 의존관계 주입을 사용하면 ***클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경***할 수 있음.
        - 의존과계 주입을 사용하면 ***정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경***할 수 있음.

### 💫 3-4. IoC 컨테이너, DI 컨테이너

- AppConfig 처럼 객체를 생성하고 관리하면서 ***의존관계를 연결해주는 것을 의미***함!
- 최근에는 주로 **DI 컨테이너**라고 함.
- 또는 **어셈블러**, **오브젝트 팩토리** 등으로 불리기도 함.
- 스프링이 DI컨테이너 역할을 함.
    - 스프링 뿐만 아니라 여러 DI컨테이너 오픈소스들이 굉장히 많음.

---

## 💫 4. 스프링으로 전환

- 지금까지 순수 자바 코드만으로 DI  컨테이너를 적용해 보았움 😊 이제 스프링 가보자구우!
    
    ![Untitled 9](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/24129ba4-b01e-44f3-b266-13bd0d52e4f7)

    
- Configuration = 설정정보, 구성정보
- 각각의 메서드에 Bean = 스프링 컨테이너에 등록하겠다!는 의미

- 스프링 컨테이너 적용
    
   ![Untitled 10](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/015a8769-661e-465a-8b44-11325d0f385f)

    
    ![Untitled 11](https://github.com/eejuuung/Spring_Study_Basic/assets/46306166/69e78649-f595-49fb-a756-6b5c456bbc27)

    
    - `ApplicationContext applicationContext` = ***스프링 컨테이너***
        - 스프링 컨테이너는 @Configuration이 붙은 ‘AppConfig’를 설정(구성)정보로 사용함. 여기서 @Bean이라 적힌 메서드를 모두 호출해 반환된 객체를 스프링 컨테이너에 등록함. 이렇게 등록된 객체를 ***스프링 빈***이라고 함.
    - `applicationContext.getBean("이름", 타입)` = 스프링 빈의 이름은 기본적으로 메서드 이름으로 등록됨.
    - 기존에는 개발자가 직접 자바코드로 모든것을 했다면 이제부터는 ***스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경됨.***

- 흠… 코드가 더 복잡한거 같은데.. 스프링 컨테이너를 사용하면 어떤 장점이 있는겨…? 왜..? 굳이 ..? 왜이렇게 써야되죠..?
    - 어마어마한 장점..? - 스프링 컨테이너가 관리해 줌으로써 해줄 수 있는 기능이 대단함.

---
