# 싱글톤 컨테이너

<br/>
<br/>

### 웹 애플리케이션과 싱글톤

→ 스프링은 기업용 온라인 서비스 기술을 지원하기 위해 탄생

<br/>

우리 코드의 문제점

→ 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.

→ 만약 우리가 만들었던 순수 DI 컨테이너를 사용한다면 AppConfig는 요청할 때마다 객체를 새로 생성

→ 여기서 고객 트래픽이 초당 100이 나오면 초당 100개의 객체가 생성되고 소멸

⇒ 메모리 낭비

<img width="672" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8 23 15" src="https://github.com/dpqls0356/Spring_Study_Basic/assets/83651122/7ef82a34-5806-44e6-b1f5-38f0b6a6a532">

<br/>
<br/>

해결방안

→ 싱클톤 패턴 사용하기 즉, 해당 객체를 하나만 만들고 공유하도록 설계

<br/>
<br/>

### 싱글톤 패턴

→ 클래스 인스턴스가 딱 하나만 생성되도록 하는 것

→ 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야한다.

→ private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막기

<br/>

- 싱글톤 패턴[ 안티패턴 ]의 문제점
    1. 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
    2. 의존관계상 클라이언트가 구체 클래스에 의존 ⇒ DIP를 위반
    3. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
    4. 테스트하기 어렵다.
    5. 내부 속성을 변경하거나 초기화 하기 어렵다.
    6. private 생성자로 자식 클래스를 만들기 어렵다.
    
    ⇒ 결론적으로 유연성이 떨어진다.
    
<br/>
<br/>


### 싱글톤 컨테이너

→ 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 1개로 관리

→ 스프링 빈이 싱글톤으로 관리되는 빈!

→ 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
<br/>
<br/>

⇒ 이전에 설명한 컨테이너 설명을 보면 객체를 하나만 생성해서 관리했었다!

⇒ 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.

⇒ 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 함

<br/>

→ 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 단점을 해결하면서 객체를 싱글톤으로 유지가 가능하다.

<img width="672" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8 23 25" src="https://github.com/dpqls0356/Spring_Study_Basic/assets/83651122/2c40ff1f-6612-4206-9180-206ad433094c">

<br/>
<br/>

### 싱글톤 방식의 주의점

→ 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유한다.

→ 그렇기에 싱글톤 객체는 상태를 유지하게 설계하면 안된다.

→ 무상태로 설계해야한다.

<br/>

⇒ 특정 클라이언트에 의존적인 필드가 존재하면 안된다.
<br/>
⇒ 특정 클라이언트가 값을 변경할 수 있는 필드가 존재하면 안된다.

<br/>
<br/>

### @configuration과 싱글톤

아래의 코드를 보면 new MemoryMemberRepository();가 두 번 호출되어 
각각 다른 객체가 생성되기에 싱글톤이 깨지는 것처럼 보일 수 있다.
하지만 실제로는 인스턴스 모두 같은 인스턴스가 공유되어 사용한다.

궁금증해결은 아래의 글을 읽어보기 ! 

```java
	
		@Bean
     public MemberService memberService() {
         return new MemberServiceImpl(memberRepository());
     }
     @Bean
     public OrderService orderService() {
         return new OrderServiceImpl(
                 memberRepository(),
                 discountPolicy());
		}
     @Bean
     public MemberRepository memberRepository() {
         return new MemoryMemberRepository();
     }
```
<br/>
<br/>

### @configuration과 바이트코드 조작의 마법

→ 위의 자바코드를 보면 이상한 점을 느낄 것!

→ 하지만 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용하기에 자연스러운 것이다.

→ 실제로 AppConfig 스프링 빈을 조회해보면 클래스 명에 이상한 이름이 추가되어있다.

→ 이것은 내가 만든 클래스가 아니라 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 
    AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것

- @Configuration 가 없이 @Bean만 사용한다면 ?
    
    스프링 빈으로 등록은 되나 싱글톤을 보장하지않아 여러 번 호출된다.
