# 섹션 1, 2 정리

### 프로젝트 환경 설정

프로젝트 생성은 예전처럼 [start.spring.io](http://start.spring.io) 에서

Gradle-Groovy 프로젝트

web, thymeleaf, jpa, h2, lombok, validation 사용

테스트 작성에 있어서 최신은 JUnit5인데 강의가 JUnit4 ? → 변경 점이 있으니 반드시 시작부터 JUnit5으로 그냥 해야 될 듯?

롬복 → Getter / Setter 굳이 안 만들어도 해주는 편리한 라이브러리로 기억하는데, 강의에서 사용하는거 확인하면서 그냥 dto 만들면서 차근차근 해볼 예정

thymeleaf를 잘 모르지만 EL, JSTL 과 유사한 듯

### 도메인 분석 설계

요즘 들어 생각하는 것이 시스템을 구현하는 것도 중요하지만 가장 중요한 것은 탄탄한 설계라고 생각이 많이 든다.

도메인 설계 부분에서 요구사항이 주어진 걸 강사님과 같이 만들어가면 좋았을 텐데 다 만들어져 있어서 좀 아쉬웠음

학부 시절에 데이터베이스부터 설계하고 진행했던 것이 기억이 좀 희미하게 나서 최종 프로젝트 준비하기 전에 반드시 따로 설계를 미리 해보는 과정이 필요할 듯

### 도메인 설계 (교재 부분 설명)

**회원(Member) →** 이름과 임베디드 타입인 주소( `Address` ), 그리고 주문( `orders` ) 리스트를 가진다.

**주문(Order) →** 한 번 주문시 여러 상품을 주문할 수 있으므로 주문과 주문상품( `OrderItem` )은 일대다 관계.

주문은 상품을 주문한 회원과 배송 정보, 주문 날짜, 주문 상태( `status` )를 가지고 있다. 주문 상태는 열거형을 사용했는데 주문( `ORDER` ), 취소( `CANCEL` )을 표현할 수 있다.

**주문상품(OrderItem) →** 주문한 상품 정보와 주문 금액( `orderPrice` ), 주문 수량( `count` ) 정보를 가지고 있다. (보통 `OrderLine` , `LineItem` 으로 많이 표현한다.)

**상품(Item) →** 이름, 가격, 재고수량( `stockQuantity` )을 가지고 있다. 상품을 주문하면 재고수량이 줄어든다. 상품의종류로는 도서, 음반, 영화가 있는데 각각은 사용하는 속성이 조금씩 다르다.

**배송(Delivery) →**주문시 하나의 배송 정보를 생성한다. 주문과 배송은 일대일 관계다.

**카테고리(Category) →** 상품과 다대다 관계를 맺는다. `parent` , `child` 로 부모, 자식 카테고리를 연결한다.

**주소(Address) →** 값 타입(임베디드 타입)이다. 회원과 배송(Delivery)에서 사용한다.

여기서 설계가 실무와 좀 맞지 않는 부분이 있다. 회원이 주문이 참조할 필요 없이 주문이 회원이 참조하는 것 만으로도 충분함.

각 테이블 설계는 우선 강사님이 미리 설계한 것을 이해하고, 따로 반드시 만들어 볼 것.

**실무 팁** → 데이터베이스 테이블 명, 컬럼명에 대한 관례는 당연히 회사마다 다르지만 보통은 대문자 + \_언더스코어 또는 소문자 + 언더스코어 조합으로 일관성있게 사용함.

Getter / Setter 에서 Getter는 열어둬도 서비스에 변경이 일어나지 않기 때문에 괜찮음, 하지만 Setter는 그렇지 않으므로 반드시 필요한 부분만, 변경을 했다면 변경 지점을 파악하기 쉽도록 비즈니스 메소드를 별도로 제공해야 함

### 엔터티 설계 주의점

**엔티티에는 가급적 Setter를 사용하지 말자**
Setter가 모두 열려있다. 변경 포인트가 너무 많아서, 유지보수가 어렵다.

나중에 리펙토링으로 Setter 제거할 것임.

**모든 연관관계는 지연로딩으로 설정**

즉시로딩( `EAGER` )은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때 N+1 문제가 자주 발생

실무에서 모든 연관관계는 지연로딩( `LAZY` )으로 설정해야 한다.
연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.

@XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.

**컬렉션은 필드에서 초기화 하자.**

null` 문제에서 안전하고, 간결하기 때문임.
