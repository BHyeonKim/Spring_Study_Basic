# 06. 스프링 DB 접근 기술

# H2 데이터베이스 설치

db를 왜 설치하는거야? 서버를 내리면 모든 데이터가 날라가버리면 안되니까 하는 것.

JPA라는 기술이 SQL 쿼리를 다 날려준다.

스프링 데이터 jpa 라는 기술이 있는데 jpa를 편리하게 쓸 수 있도록 한번 감싼 것이다.

H2는 가벼워서 교육용으로 좋다.

다운받아서 압축풀면 `bin`에 `h2.sh` 이 있으니 실행하면 된다.

상황에 따라서 IP때문에 안될때가 있다.

뒤는 절대 건들지마라(세션 키 같은 것이 있음)

앞에만 [localhost:8082](http://localhost:8082) 등으로 바꾸어주면 아마 될것이다.

최초에는, 데이터베이스 파일이라는 것을 만들어야 한다.

JDBC URL 은 내 홈에 있는 파일을 의미한다. 사용자 명, 비밀번호 입력하고 들어갈수있다.

이후에는 파일로 접근하면 웹 콘솔이라고 하는거랑 같이 접근이 안될 수가있다.

⇒ 충돌이 나기 때문

만약 문제가 생기면 `test.mv.db` 라는 파일을 지워주고 연결도 끊어버리고 다시 하면 된다.

가끔 연결이 잘안될때가 있다고 한다.

제일먼저 해야할것은?

테이블을 만드는 것이다.

```sql
 create table member
 (
    id   bigint generated by default as identity,
    name varchar(255),
		primary key (id)
 );
```

id에 null 값을 넣으면 db가 자동으로 채워준다. (위처럼 테이블을 만들면)

id를 생략하고 데이터를 집어 넣으면 자동으로 1 2 이렇게 id가 들어간다.

김영한쌤은 그냥 폴더 sql 을 만든 다음에 그 안에 ddl.sql 을 만든 다음에 관리를 한대.

참고로 내 로컬에서 돌리고 있는 db를 끄면 안된다!!

# 순수 JDBC

고대의 20년 정도된 방식으로 한번해보자.

참고로 이거는 정신건강을 위해서 그냥 편하게 듣기만 하고 굳이 외우거나 하지 말래.

어차피 필요하면 검색해서 보면 되고 이제는 안쓰는 방법이니까.

db에 붙으려면 `datasource`가 필요하다. 그냥 그렇구나 하고 들으래 이해할필요 x

스프링이 데이터 소스를 주입해준다.

데이터베이스와 연결되는 소켓을 열수있는건데, 간단해보이겠지만 코딩이 어마어마하다.

수도코드로만 보여주겠대. 치고있는 시간도 아깝다고 하심

절대 이렇게 짜지말아라!! 이제는 완전 사장된 방법이다!!

# 스프링 통합 테스트

테스트를 스프링이랑 엮어서 한번 해보도록 하겠대.

`@SpringBootTest` , `@Transactional` 어노테이션을 붙여준다.

기존 코드들을 생성하는 인젝션이 좋은데, 테스트를 내가 어디가서 가져다 쓰는것이 아니니까 테스트 케이스를 할때는 그냥 필드 기반으로 `Autowired`를 받는 것도 편하다.

회원가입을 돌렸는데 에러가 나.

왜? 이미 db에 내가 테스트한다고 데이터를 넣어줘버렸기 때문임.

삭제해도 ID는 계속 올라감. 그냥 db자체가 그런 메커니즘을 갖고 있는 녀석이라서 그런거니까 신경 ㄴㄴ

테스트는 반복할 수 있어야하는데 테스트한다고 spring이라는 데이터를 db에 넣어버리면 다음에 또 돌릴때는 중복회원 에러가 난다.

그래서 delete 하는 코드를 짜줘야하는데 너무 귀찮잖아.

그래서 스프링이 제공하는 기능을 사용하는것이다. 원래 db에 데이터를 넣은 다음 커밋을 해줘야 db에 반영이 된다. 커밋을 안하면 반영이 되지 않는다.

테스트 끝난 다음 롤백해버리면 db에 반영을 안하고 테스트해볼수있다. 그 기능을 `@Transactional` 이 해주는 것이다.

# 스프링 JdbcTemplate

중복을 제거해서 만든것이다. 실무에서도 많이 쓴다.

이전에 데이터 소스 인젝션 받았던 것처럼, dataSource를 인젝션을 받고, 데이터 소스를 넣어주면 된다.

생성자가 하나만 있으면, 스프링 빈으로 등록되어서 오토와이어를 생략할 수 있다.

`JdbcTemplateMemberRepository 클래스`

```java
public class JdbcTemplateMemberRepository implements MemberRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {

        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());

        Number key = jdbcInsert.executeAndReturnKey(new
                MapSqlParameterSource(parameters));
        member.setId(key.longValue());

        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id 
                = ?", memberRowMapper(), id);
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    @Override
    public Optional<Member> findByName(String name) {

        List<Member> result = jdbcTemplate.query("select * from member where 
                name = ?", memberRowMapper(), name);
        return result.stream().findAny();
    }

    private RowMapper<Member> memberRowMapper() {

        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
}
```

쿼리를 짤 필요가 없다.

이 코드가 스스로 인서트 문등 sql 쿼리를 만들어서 짜주고, document를 참고하여 코드를 짜면 된다.

그냥 전반적으로 아 이렇구나 하고 넘어가면 된다!

근데 오류가 났어

ㅋㅋㅋ 파라미터가 세팅이 제대로 안되어있었던거래

테스트케이스가 있기 때문에 이렇게 잘 찾을 수 있었던거야.

ㄷㄷ 60~70%는 테스트코드 짜는 시간이고 실제 프로덕션 코드는 10% 20% 정도래.. 그정도로 규모가 커지면 테스트코드가 중요하대.

# JPA

쿼리까지 다 없애버릴수있대.

JDBC → JDBC 템플릿 으로 하니까 반복되는 코드가 많이 줄긴함. 그런데 아직 해결안되는 문제가 있어. SQL은 아직도 개발자가 작성을 해줘야함.

JPA 라는 기술을 사용하면 SQL 쿼리도 자동으로 처리를 해준대.

JPA가 중간에서 DB에 SQL을 날리고 받아오고를 다 처리를 해준대.

SQL보다는 객체 중심의 설계로 패러다임을 전환할 수 있대.

ㅋㅋㅋ PPL을 하심. 김영한씨의 책을 읽어보는것도 좋을듯

ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ2015년부터 트렌드가 올라갔는데 자기 책도 2015년에 나왔대 ㅋㅋ

글로벌하게보면 마이바티스보다 JPA가 더 많이 쓰인대.

스프링 프레임워크는 너무 큰 기술이라서 망망대해에 떠있는 느낌이래. JPA도 정말 깊이가 깊은 기능이라서 공부를 제대로 하는게 좋대.

`build.gradle` 

```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    // implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.h2database:h2'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
}
```

`aplication.properties`

```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```

이렇게 두 개 해주어야한다.

테이블을 자동으로 생성해주는 기능이 필요하면 ddl-auto를 켜면 된다.

뒤를 create로 바꾸어주면된다.

jpa를 쓰려면 엔티티랑 매핑을 해주어야 한다.

jpa랑 hibernate 라이브러리가 들어와 있어야 한다. 그래야 사용할 수 있다.

jpa는 java 진영의 표준이고, 회사가 그걸 보고 구현을 하는거라서 업체마다 성능의 차이가 있을 수 있다.

jpa는 orm 객체의 o, 관계의 r, 매핑의 m 이래.

엔티티 매핑을 먼저 해준다.

```java
@Entity
public class Member {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getName() {
    }
 return name;
    public void setName(String name) {
        this.name = name;
    }
}
```

이걸 가지고 해주는건데, 만약에 db에 name이 아니라 뭐 예를들어 username이라고 되어있으면 `@Column(name = “username”)` 이거를 변수 위에 써줌으로써 매핑을 직접적으로 시켜줄 수도 있다.

이제 이 정보를 가지고 insert, delete 문 등등을 만들어주는 것이다.

결론 : jpa를 쓰려면 entitiy manager를 주입받아야한다.

```java
public class JpaMemberRepository implements MemberRepository {

    private final EntityManager em;

		// entity manager 주입받기
    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

		// 이렇게만 해주면 된다
    public Member save(Member member) {
        em.persist(member);
        return member;
    }

    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

		// 보면 객체 자체를 select한다 * 같은 것을 사용하는데 jpa를 쓰면 이렇게 쓴다
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }

    public Optional<Member> findByName(String name) {
        List<Member> result = em.createQuery("select m from Member m where 
                m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
        return result.stream().findAny();
    }
}
```

Hibernate : 이렇게 콘솔에 찍히니 확인해보자

@commit 이걸 붙여주면 test여도 db에 커밋이 되긴한다.

# Spring data JPA

실무에서 R DB를 사용하면 JPA는 필수이다.

JPA를 먼저 배우고 그 다음에 Spring data JPA를 배우는 것을 추천한다.

왜냐하면 JPA를 도와주는 도구가 Spring data JPA이기 때문이다.

새로 ineteface를 만들어준다.

`SpringDataJpaMemberRepository`

```java
public interface SpringDataJpaMemberRepository extends JpaRepository<Member,
        Long>, MemberRepository {

    Optional<Member> findByName(String name);
}
```

이렇게만 해주면 끝이다

스프링 데이터 jpa가 jpa 리포지토리를 받고 있으면 구현체를 자동으로 만들어준다. 내가 스프링 빈에 등록하는 것이 아니라 스프링 데이터 JPA가 요거를 보고 자기가 구현체를 만들어서 해준다.

`SpringConfig` 변경

```java
@Configuration
public class SpringConfig {
    private final MemberRepository memberRepository;
    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository);
    }
}
```

기본적인 CRUD와 단순 기능이 다 제공이 되기때문에 가져다 쓰면 된다.

강의 노트의 JPA 클래스 다이어그램을 참고하면 이해가 잘된다.

실무에서는 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 쓰면 되고 정 안될거같은거는 네이티브 쿼리나 jdbcTemplate를 사용하면 된다!
